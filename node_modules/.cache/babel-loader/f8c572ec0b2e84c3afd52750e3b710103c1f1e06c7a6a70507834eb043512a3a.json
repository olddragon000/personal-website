{"ast":null,"code":"import _slicedToArray from\"/Users/jialiangzhou/cs1300/portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{useEffect,useState}from\"react\";export default function useOnScreen(ref){var _useState=useState(false),_useState2=_slicedToArray(_useState,2),isIntersecting=_useState2[0],setIntersecting=_useState2[1];var observer=new IntersectionObserver(function(_ref){var _ref2=_slicedToArray(_ref,1),entry=_ref2[0];return setIntersecting(entry.isIntersecting);});useEffect(function(){observer.observe(ref.current);// Remove the observer as soon as the component is unmounted\nreturn function(){observer.disconnect();};},[]);return isIntersecting;}","map":{"version":3,"names":["useEffect","useState","useOnScreen","ref","isIntersecting","setIntersecting","observer","IntersectionObserver","entry","observe","current","disconnect"],"sources":["/Users/jialiangzhou/cs1300/portfolio/src/components/useOnScreen.tsx"],"sourcesContent":["import {useEffect, useState} from \"react\";\n\nexport default function useOnScreen(ref:any) {\n\n    const [isIntersecting, setIntersecting] = useState(false)\n\n    const observer = new IntersectionObserver(\n        ([entry]) => setIntersecting(entry.isIntersecting)\n    )\n\n    useEffect(() => {\n        observer.observe(ref.current)\n        // Remove the observer as soon as the component is unmounted\n        return () => {\n            observer.disconnect()\n        }\n    }, [])\n\n    return isIntersecting\n}"],"mappings":"0HAAA,OAAQA,SAAS,CAAEC,QAAQ,KAAO,OAAO,CAEzC,cAAe,SAASC,YAAW,CAACC,GAAO,CAAE,CAEzC,cAA0CF,QAAQ,CAAC,KAAK,CAAC,wCAAlDG,cAAc,eAAEC,eAAe,eAEtC,GAAMC,SAAQ,CAAG,GAAIC,qBAAoB,CACrC,gDAAEC,KAAK,gBAAMH,gBAAe,CAACG,KAAK,CAACJ,cAAc,CAAC,GACrD,CAEDJ,SAAS,CAAC,UAAM,CACZM,QAAQ,CAACG,OAAO,CAACN,GAAG,CAACO,OAAO,CAAC,CAC7B;AACA,MAAO,WAAM,CACTJ,QAAQ,CAACK,UAAU,EAAE,CACzB,CAAC,CACL,CAAC,CAAE,EAAE,CAAC,CAEN,MAAOP,eAAc,CACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}